// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countActiveProducts = `-- name: CountActiveProducts :one
SELECT COUNT(*) FROM istanahp.products
WHERE is_active = TRUE AND deleted_at IS NULL
`

func (q *Queries) CountActiveProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM istanahp.products
WHERE deleted_at IS NULL
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO istanahp.products (
    category_id,
    tax_rate_id,
    name,
    sku,
    description,
    retail_price,
    customer_price,
    reorder_level,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.CategoryID,
		arg.TaxRateID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.RetailPrice,
		arg.CustomerPrice,
		arg.ReorderLevel,
		arg.IsActive,
	)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductCostLot = `-- name: CreateProductCostLot :one
INSERT INTO istanahp.product_cost_lots (
    product_id,
    quantity,
    unit_cost,
    purchase_item_id,
    received_at,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at
`

type CreateProductCostLotParams struct {
	ProductID      int64
	Quantity       int32
	UnitCost       string
	PurchaseItemID sql.NullInt64
	ReceivedAt     time.Time
	ExpiresAt      sql.NullTime
}

func (q *Queries) CreateProductCostLot(ctx context.Context, arg CreateProductCostLotParams) (IstanahpProductCostLot, error) {
	row := q.db.QueryRowContext(ctx, createProductCostLot,
		arg.ProductID,
		arg.Quantity,
		arg.UnitCost,
		arg.PurchaseItemID,
		arg.ReceivedAt,
		arg.ExpiresAt,
	)
	var i IstanahpProductCostLot
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitCost,
		&i.PurchaseItemID,
		&i.ReceivedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM istanahp.products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getCostLotsByDateRange = `-- name: GetCostLotsByDateRange :many
SELECT pcl.id, pcl.product_id, pcl.quantity, pcl.unit_cost, pcl.purchase_item_id, pcl.received_at, pcl.expires_at, pcl.created_at, pcl.updated_at, p.name as product_name, p.sku
FROM istanahp.product_cost_lots pcl
JOIN istanahp.products p ON pcl.product_id = p.id
WHERE pcl.received_at BETWEEN $1 AND $2
ORDER BY pcl.received_at DESC
`

type GetCostLotsByDateRangeParams struct {
	ReceivedAt   time.Time
	ReceivedAt_2 time.Time
}

type GetCostLotsByDateRangeRow struct {
	ID             int64
	ProductID      int64
	Quantity       int32
	UnitCost       string
	PurchaseItemID sql.NullInt64
	ReceivedAt     time.Time
	ExpiresAt      sql.NullTime
	CreatedAt      time.Time
	UpdatedAt      time.Time
	ProductName    string
	Sku            string
}

func (q *Queries) GetCostLotsByDateRange(ctx context.Context, arg GetCostLotsByDateRangeParams) ([]GetCostLotsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getCostLotsByDateRange, arg.ReceivedAt, arg.ReceivedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCostLotsByDateRangeRow
	for rows.Next() {
		var i GetCostLotsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitCost,
			&i.PurchaseItemID,
			&i.ReceivedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredCostLots = `-- name: GetExpiredCostLots :many
SELECT id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at FROM istanahp.product_cost_lots
WHERE expires_at IS NOT NULL 
  AND expires_at < CURRENT_DATE 
  AND quantity > 0
ORDER BY expires_at ASC
`

func (q *Queries) GetExpiredCostLots(ctx context.Context) ([]IstanahpProductCostLot, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredCostLots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProductCostLot
	for rows.Next() {
		var i IstanahpProductCostLot
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitCost,
			&i.PurchaseItemID,
			&i.ReceivedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT p.id, p.category_id, p.tax_rate_id, p.name, p.sku, p.description, p.retail_price, p.customer_price, p.reorder_level, p.is_active, p.created_at, p.updated_at, p.deleted_at, il.current_stock 
FROM istanahp.products p
JOIN istanahp.inventory_levels il ON p.id = il.product_id
WHERE p.reorder_level > 0 
  AND il.current_stock <= p.reorder_level 
  AND p.is_active = TRUE 
  AND p.deleted_at IS NULL
ORDER BY p.name ASC
`

type GetLowStockProductsRow struct {
	ID            int64
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	DeletedAt     sql.NullTime
	CurrentStock  int32
}

func (q *Queries) GetLowStockProducts(ctx context.Context) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLowStockProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldestCostLot = `-- name: GetOldestCostLot :one

SELECT id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at FROM istanahp.product_cost_lots
WHERE product_id = $1 AND quantity > 0
ORDER BY received_at ASC
LIMIT 1
`

// FIFO ordering
func (q *Queries) GetOldestCostLot(ctx context.Context, productID int64) (IstanahpProductCostLot, error) {
	row := q.db.QueryRowContext(ctx, getOldestCostLot, productID)
	var i IstanahpProductCostLot
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitCost,
		&i.PurchaseItemID,
		&i.ReceivedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, id int64) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE sku = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, getProductBySKU, sku)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductCategories = `-- name: GetProductCategories :many
SELECT id, name, description, created_at, updated_at, deleted_at FROM istanahp.product_categories
WHERE deleted_at IS NULL
`

func (q *Queries) GetProductCategories(ctx context.Context) ([]IstanahpProductCategory, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProductCategory
	for rows.Next() {
		var i IstanahpProductCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCostLot = `-- name: GetProductCostLot :one
SELECT id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at FROM istanahp.product_cost_lots
WHERE id = $1
`

func (q *Queries) GetProductCostLot(ctx context.Context, id int64) (IstanahpProductCostLot, error) {
	row := q.db.QueryRowContext(ctx, getProductCostLot, id)
	var i IstanahpProductCostLot
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitCost,
		&i.PurchaseItemID,
		&i.ReceivedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductCostSummary = `-- name: GetProductCostSummary :one
SELECT 
    p.id,
    p.name,
    p.sku,
    COALESCE(SUM(pcl.quantity), 0) as total_quantity,
    COALESCE(SUM(pcl.quantity * pcl.unit_cost), 0) as total_value,
    CASE 
        WHEN SUM(pcl.quantity) > 0 
        THEN SUM(pcl.quantity * pcl.unit_cost) / SUM(pcl.quantity)
        ELSE 0 
    END as weighted_avg_cost
FROM istanahp.products p
LEFT JOIN istanahp.product_cost_lots pcl ON p.id = pcl.product_id AND pcl.quantity > 0
WHERE p.id = $1 AND p.deleted_at IS NULL
GROUP BY p.id, p.name, p.sku
`

type GetProductCostSummaryRow struct {
	ID              int64
	Name            string
	Sku             string
	TotalQuantity   interface{}
	TotalValue      interface{}
	WeightedAvgCost int32
}

func (q *Queries) GetProductCostSummary(ctx context.Context, id int64) (GetProductCostSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getProductCostSummary, id)
	var i GetProductCostSummaryRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.TotalQuantity,
		&i.TotalValue,
		&i.WeightedAvgCost,
	)
	return i, err
}

const listActiveProducts = `-- name: ListActiveProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE is_active = TRUE AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListActiveProducts(ctx context.Context) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listActiveProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductCostLots = `-- name: ListProductCostLots :many
SELECT id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at FROM istanahp.product_cost_lots
WHERE product_id = $1 AND quantity > 0
ORDER BY received_at ASC
`

func (q *Queries) ListProductCostLots(ctx context.Context, productID int64) ([]IstanahpProductCostLot, error) {
	rows, err := q.db.QueryContext(ctx, listProductCostLots, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProductCostLot
	for rows.Next() {
		var i IstanahpProductCostLot
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitCost,
			&i.PurchaseItemID,
			&i.ReceivedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE category_id = $1 AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListProductsByCategory(ctx context.Context, categoryID sql.NullInt64) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE (
    name ILIKE '%' || $1 || '%' OR
    sku ILIKE '%' || $1 || '%' OR
    description ILIKE '%' || $1 || '%'
) AND deleted_at IS NULL
ORDER BY name ASC
LIMIT $2 OFFSET $3
`

type SearchProductsParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE istanahp.products
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteProduct, id)
	return err
}

const updateCostLotQuantity = `-- name: UpdateCostLotQuantity :one
UPDATE istanahp.product_cost_lots
SET 
    quantity = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, product_id, quantity, unit_cost, purchase_item_id, received_at, expires_at, created_at, updated_at
`

type UpdateCostLotQuantityParams struct {
	ID       int64
	Quantity int32
}

func (q *Queries) UpdateCostLotQuantity(ctx context.Context, arg UpdateCostLotQuantityParams) (IstanahpProductCostLot, error) {
	row := q.db.QueryRowContext(ctx, updateCostLotQuantity, arg.ID, arg.Quantity)
	var i IstanahpProductCostLot
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitCost,
		&i.PurchaseItemID,
		&i.ReceivedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE istanahp.products
SET 
    category_id = $2,
    tax_rate_id = $3,
    name = $4,
    sku = $5,
    description = $6,
    retail_price = $7,
    customer_price = $8,
    reorder_level = $9,
    is_active = $10,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID            int64
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.CategoryID,
		arg.TaxRateID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.RetailPrice,
		arg.CustomerPrice,
		arg.ReorderLevel,
		arg.IsActive,
	)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductPrice = `-- name: UpdateProductPrice :one
UPDATE istanahp.products
SET 
    retail_price = $2,
    customer_price = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductPriceParams struct {
	ID            int64
	RetailPrice   string
	CustomerPrice sql.NullString
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProductPrice, arg.ID, arg.RetailPrice, arg.CustomerPrice)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductStatus = `-- name: UpdateProductStatus :one
UPDATE istanahp.products
SET 
    is_active = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductStatusParams struct {
	ID       int64
	IsActive bool
}

func (q *Queries) UpdateProductStatus(ctx context.Context, arg UpdateProductStatusParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProductStatus, arg.ID, arg.IsActive)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
