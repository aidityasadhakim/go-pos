// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countActiveProducts = `-- name: CountActiveProducts :one
SELECT COUNT(*) FROM istanahp.products
WHERE is_active = TRUE AND deleted_at IS NULL
`

func (q *Queries) CountActiveProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM istanahp.products
WHERE deleted_at IS NULL
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO istanahp.products (
    category_id,
    tax_rate_id,
    name,
    sku,
    description,
    cost_price,
    retail_price,
    customer_price,
    reorder_level,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	CostPrice     string
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.CategoryID,
		arg.TaxRateID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.CostPrice,
		arg.RetailPrice,
		arg.CustomerPrice,
		arg.ReorderLevel,
		arg.IsActive,
	)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM istanahp.products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT p.id, p.category_id, p.tax_rate_id, p.name, p.sku, p.description, p.cost_price, p.retail_price, p.customer_price, p.reorder_level, p.is_active, p.created_at, p.updated_at, p.deleted_at, il.current_stock 
FROM istanahp.products p
JOIN istanahp.inventory_levels il ON p.id = il.product_id
WHERE p.reorder_level > 0 
  AND il.current_stock <= p.reorder_level 
  AND p.is_active = TRUE 
  AND p.deleted_at IS NULL
ORDER BY p.name ASC
`

type GetLowStockProductsRow struct {
	ID            int64
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	CostPrice     string
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	DeletedAt     sql.NullTime
	CurrentStock  int32
}

func (q *Queries) GetLowStockProducts(ctx context.Context) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLowStockProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CostPrice,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, id int64) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE sku = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, getProductBySKU, sku)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveProducts = `-- name: ListActiveProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE is_active = TRUE AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListActiveProducts(ctx context.Context) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listActiveProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CostPrice,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CostPrice,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE category_id = $1 AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListProductsByCategory(ctx context.Context, categoryID sql.NullInt64) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CostPrice,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at FROM istanahp.products
WHERE (
    name ILIKE '%' || $1 || '%' OR
    sku ILIKE '%' || $1 || '%' OR
    description ILIKE '%' || $1 || '%'
) AND deleted_at IS NULL
ORDER BY name ASC
LIMIT $2 OFFSET $3
`

type SearchProductsParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]IstanahpProduct, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IstanahpProduct
	for rows.Next() {
		var i IstanahpProduct
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.TaxRateID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.CostPrice,
			&i.RetailPrice,
			&i.CustomerPrice,
			&i.ReorderLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE istanahp.products
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteProduct, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE istanahp.products
SET 
    category_id = $2,
    tax_rate_id = $3,
    name = $4,
    sku = $5,
    description = $6,
    cost_price = $7,
    retail_price = $8,
    customer_price = $9,
    reorder_level = $10,
    is_active = $11,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID            int64
	CategoryID    sql.NullInt64
	TaxRateID     sql.NullInt64
	Name          string
	Sku           string
	Description   sql.NullString
	CostPrice     string
	RetailPrice   string
	CustomerPrice sql.NullString
	ReorderLevel  int32
	IsActive      bool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.CategoryID,
		arg.TaxRateID,
		arg.Name,
		arg.Sku,
		arg.Description,
		arg.CostPrice,
		arg.RetailPrice,
		arg.CustomerPrice,
		arg.ReorderLevel,
		arg.IsActive,
	)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductPrice = `-- name: UpdateProductPrice :one
UPDATE istanahp.products
SET 
    cost_price = $2,
    retail_price = $3,
    customer_price = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductPriceParams struct {
	ID            int64
	CostPrice     string
	RetailPrice   string
	CustomerPrice sql.NullString
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProductPrice,
		arg.ID,
		arg.CostPrice,
		arg.RetailPrice,
		arg.CustomerPrice,
	)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductStatus = `-- name: UpdateProductStatus :one
UPDATE istanahp.products
SET 
    is_active = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, category_id, tax_rate_id, name, sku, description, cost_price, retail_price, customer_price, reorder_level, is_active, created_at, updated_at, deleted_at
`

type UpdateProductStatusParams struct {
	ID       int64
	IsActive bool
}

func (q *Queries) UpdateProductStatus(ctx context.Context, arg UpdateProductStatusParams) (IstanahpProduct, error) {
	row := q.db.QueryRowContext(ctx, updateProductStatus, arg.ID, arg.IsActive)
	var i IstanahpProduct
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.TaxRateID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.CostPrice,
		&i.RetailPrice,
		&i.CustomerPrice,
		&i.ReorderLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
